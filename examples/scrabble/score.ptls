rankInfo = Table.of({
  rank: ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"],
  value: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10],
  index: range(13),
})

fn getValue(card)
  rankInfo[{ rank: card.rank }].value
end

fn getIndex(card)
  rankInfo[{ rank: card.rank }].index
end

symbols = {
  h: "♥",
  d: "♦",
  c: "♣",
  s: "♠",
}

deck = Table.new(["rank", "suit"])

for rank in rankInfo.rank do
  for suit in symbols do
    deck |= push({ rank, suit })
  end
end

fn show(card)
  symbol = symbols[card.suit]
  "$card.rank$symbol"
end

fn showCards(cards)
  cards
    $ show
    | join(" ")
end

fn subsets(cards)
  cards
    | Set.of
    | Set.powerset
    | remove(Set.empty)
    $ List.of
    $ Table.of
end

fn is15(cards)
  cards
    $ getValue
    | sum
    | arg == 15
end

fn isPair(cards)
  len(cards) == 2 and cards[0].rank == cards[1].rank
end

fn isRun(cards)
  n = len(cards)

  if n < 3 then
    return false
  end

  indices = cards
    $ getIndex
    | List.unique

  len(indices) == n and max(indices) - min(indices) + 1 == n
end

fn isFlush(cards)
  len(List.unique(cards.suit)) == 1
end

fn getScoreItems(hand)
  scoreItems = Table.new(["type", "cards"])

  for cards in subsets(hand) do
    if is15(cards) then
      scoreItems |= push({ type: "15", cards })
    end

    if isPair(cards) then
      scoreItems |= push({ type: "pair", cards })
    end

    if isRun(cards) then
      scoreItems |= push({ type: "run", cards })
    end
  end

  if isFlush(hand) then
    scoreItems |= push({ type: "flush", cards: hand })
  end

  maxRun = scoreItems
    ? arg.type == "run"
    $ len(arg.cards)
    | List.maxNone

  scoreItems ?= not (arg.type == "run" and len(arg.cards) < maxRun)
  scoreItems.score = scoreItems $ calcScore

  scoreItems
    | Table.focus(["type", "score"])
    | sortBy("type")
end

fn calcScore(scoreItem)
  match scoreItem.type
    case "15" then 2
    case "pair" then 2 
    case "run" then len(scoreItem.cards)
    case "flush" then len(scoreItem.cards)
  end
end

----

deal = Table.of([
  { rank: "6", suit: "h" },
  { rank: "7", suit: "h" },
  { rank: "8", suit: "h" },
  { rank: "8", suit: "d" },
  { rank: "8", suit: "s" },
  { rank: "9", suit: "h" },
])

----

fn makeHand(cards)
  scoreItems = getScoreItems(cards)
  {
    cards,
    scoreItems,
    str: showCards(cards),
    score: sum(scoreItems.score),
  }
end

deal
  | subsets
  ? len(arg) == 4
  $ makeHand
  | List.maxAll(fn(hand) hand.score end)
  | Table.of
  | select(["str", "score"])
  | print

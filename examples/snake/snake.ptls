size = 10
deltaRef = Ref.of({ x: 1, y: 0 })

fn newGoal()
  x = Rand.range(size)
  y = Rand.range(size)
  { x, y }
end

fn printBoard(board)
  border = "──" * size

  board
    $ join("")
    $ "│$arg│"
    | join("\n")
    | "┌$border┐\n$arg\n└$border┘"
    | print
end

fn setBlock(board, loc, code)
  board[loc.y][loc.x] = "\u{1b}[$(code)m██\u{1b}[0m"
  board
end

fn render(game)
  board = [["  "] * size] * size

  board |= setBlock(game.goal, 31)

  for loc in game.body do
    board |= setBlock(loc, 34)
  end

  board |= setBlock(game.head, 32)

  clear()
  print("score: $game.score")
  printBoard(board)
end

fn update(game)
  game.body |= push(game.head)

  if not game.growing then
    game.body |= drop(1)
  end

  game.growing = false

  delta = Ref.get(deltaRef)

  game.head.x += delta.x
  game.head.y += delta.y

  if game.head in game.body or not inBounds(game.head) then
    game.playing = false
    return game
  end
  
  if atGoal(game) then
    game.growing = true
    game.score += 1

    while atGoal(game) do
      game.goal = newGoal()
    end
  end

  render(game)
  game
end

fn inBounds(head)
  head.x >= 0 and head.x < size and
  head.y >= 0 and head.y < size
end

fn atGoal(game)
  game.goal == game.head or game.goal in game.body
end

deltas = {
  left: { x: -1, y: 0 },
  right: { x: 1, y: 0 },
  up: { x: 0, y: -1 },
  down: { x: 0, y: 1 },
}

fn getInput()
  while true do
    key = Console.rawKey().name
    Ref.set(deltaRef, deltas[key])
  end
end

fn tick()
  game = {
    size,
    fps: 8,
    playing: true,
    growing: false,
    head: { x: 1, y: 1 },
    body: #{ x , y },
    goal: newGoal(),
    score: 0,
  }

  while game.playing do
    game |= update
    sleep(1000 / game.fps)
  end

  -- Temporary workaround for lack of JS promise cancellation
  Console.pauseStdin()
end

Async.getFirst([getInput, tick])

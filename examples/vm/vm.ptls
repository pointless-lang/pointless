source = import "lines:chart.asm"

instrs = source
  $ str.trim
  ? not (isEmpty(arg) or str.startsWith(arg, "--"))

vm = {
  ip: 0,
  lastMem: none,
  output: "",
  halted: false,
  steps: 0,
  registers: [0] * 4,
  memory: [],
}

fn regIndex(regName)
  regName
    | drop(1)
    | str.toNum
end

fn evalArg(token, vm)
  if str.startsWith(token, "r") then
    vm.registers[regIndex(token)]
  else
    str.toNum(token)
  end
end

binOps = set.of([
  "add", "sub", "mul", "div", "mod", "eq", "gt", "lt", "and", "or"
])

fn boolToNum(boolean)
  if boolean then 1 else 0 end
end

fn binOp(op, a, b)
  match op
    case "add" then a + b
    case "sub" then a - b
    case "mul" then a * b
    case "div" then floor(a / b)
    case "mod" then a % b
    case "eq"  then boolToNum(a == b)
    case "gt"  then boolToNum(a > b)
    case "lt"  then boolToNum(a < b)
    case "and" then boolToNum(a != 0 and b != 0)
    case "or"  then boolToNum(a != 0 or b != 0)
  end
end

fn runInst(vm, inst)
  tokens = split(inst, " ")
  op = tokens[0]

  setReg = fn(vm, value)
    vm.registers[regIndex(tokens[1])] = value
    vm
  end

  args = tokens
    | drop(1)
    $ evalArg(vm)

  if has(binOps, op) then
    vm |= setReg(binOp(op, args[0], args[1]))
    vm.ip += 1
    return vm
  end

  ipDelta = 1

  match op
    case "not" then
      vm |= setReg(boolToNum(args[0] == 0))
    case "set" then
      vm |= setReg(args[1])
    case "jmp" then
      ipDelta = args[0]
    case "jeq" then
      ipDelta = if args[1] == args[2] then args[0] else 1 end
    case "jne" then
      ipDelta = if args[1] != args[2] then args[0] else 1 end
    case "halt" then
      vm.halted = true
    case "init" then
      vm.memory = args
    case "load" then
      vm |= setReg(vm.memory[args[1]])
      vm.lastMem = args[1]
    case "store" then
      vm.memory[args[1]] = args[0]
      vm.lastMem = args[1]
    case "print" then
      vm.output += char.of(args[0])
    else
      throw({ err: "invalid instruction", op })
  end

  vm.ip += ipDelta
  vm
end

fn logInstrs(vm)
  for index, inst in instrs do
    if vm.ip == index then
      print("> $inst")
    else
      print("  $inst")
    end
  end
end

fn logRegs(vm)
  print("")
  for index, value in vm.registers do
    print("r$index: $value")
  end
end

fn logMem(vm)
  print("")
  items = []

  for index, n in vm.memory do
    if index == vm.lastMem then
      items |= push("*$n")
    else
      items |= push(" $n")
    end
  end

  items
    | join(", ")
    | print("memory: [$arg]")
end

fn logOutput(vm)
  console.write("\n$vm.output")
end

fn run(vm)
  while not vm.halted do
    clear()
    logInstrs(vm)
    vm |= runInst(instrs[vm.ip])
    logRegs(vm)
    logMem(vm)
    logOutput(vm)
    sleep(40)
  end
end

run(vm)

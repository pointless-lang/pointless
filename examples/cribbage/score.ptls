values = { "A": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "10": 10, "J": 10, "Q": 10, "K": 10 }
ranks = Obj.keys(values)

symbols = {
  h: "♥",
  d: "♦",
  c: "♣",
  s: "♠",
}

deck = Obj.product({ ranks, symbols })

fn show(card)
  symbol = symbols[card.suit]
  "$card.rank$symbol"
end

fn showCards(cards)
  cards
    $ show
    | join(" ")
end

fn subsets(cards)
  cards
    | Set.powerset
    | remove(Set.empty)
    $ List.of
    $ Table.of
end

fn is15(cards)
  cards
    $ values[arg.rank]
    | sum
    | arg == 15
end

fn isPair(cards)
  len(cards) == 2 and cards[0].rank == cards[1].rank
end

fn isRun(cards)
  n = len(cards)

  if n < 3 then
    return false
  end

  indices = cards
    $ List.indexOf(arg.rank, ranks)
    | List.unique

  len(indices) == n and max(indices) - min(indices) + 1 == n
end

fn isFlush(cards)
  len(List.unique(cards.suit)) == 1
end

fn getScoreItems(hand)
  scoreItems = Table.new(["type", "cards"])

  for cards in subsets(hand) do
    if is15(cards) then
      scoreItems |= push({ type: "15", cards })
    end

    if isPair(cards) then
      scoreItems |= push({ type: "pair", cards })
    end

    if isRun(cards) then
      scoreItems |= push({ type: "run", cards })
    end
  end

  if isFlush(hand) then
    scoreItems |= push({ type: "flush", cards: hand })
  end

  maxRun = scoreItems
    ? arg.type == "run"
    $ len(arg.cards)
    | List.maxNone

  scoreItems ?= not (arg.type == "run" and len(arg.cards) < maxRun)
  scoreItems.score = scoreItems $ calcScore

  scoreItems
    | Table.focus(["type", "score"])
    | sortBy("type")
end

fn calcScore(scoreItem)
  match scoreItem.type
    case "15" then 2
    case "pair" then 2 
    case "run" then len(scoreItem.cards)
    case "flush" then len(scoreItem.cards)
  end
end

----

deal = Table.of([
  { rank: "6", suit: "h" },
  { rank: "7", suit: "h" },
  { rank: "8", suit: "h" },
  { rank: "8", suit: "d" },
  { rank: "8", suit: "s" },
  { rank: "9", suit: "h" },
])

----

fn makeHand(cards)
  scoreItems = getScoreItems(cards)
  {
    cards,
    scoreItems,
    str: showCards(cards),
    score: sum(scoreItems.score),
  }
end

deal
  | subsets
  ? len(arg) == 4
  $ makeHand
  | List.maxAll(fn(hand) hand.score end)
  | Table.of
  | select(["str", "score"])
  | print

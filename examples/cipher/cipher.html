<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="../../docs/notebook.css" />
    <title>cipher</title>
  </head>

  <body>
    <main>
      <div class="docs">
        <div>
          <h1>
            <a
              name="pointless-learning-by-example"
              href="#pointless-learning-by-example"
              >Pointless: Learning by Example</a
            >
          </h1>
          <p>
            Let&#39;s see an example to get a feel for the language. I&#39;ll
            show you how I wrote the following program, which can encode and
            decode a message using a simple cipher.
          </p>
          <div class="snippet">
            <pre><code class="ptls">alphabet <span class="operator">=</span> <span class="call">chars</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>)

<span class="comment">-- Shift a single letter 13 places</span>

<span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">list</span>.<span class="call">indexOf</span>(alphabet, <span class="std">str</span>.<span class="call">toLower</span>(letter))

  <span class="keyword">if</span> index <span class="operator">==</span> <span class="constant">none</span> <span class="keyword">then</span>
    letter
  <span class="keyword">else</span>
    shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]

    <span class="keyword">if</span> <span class="std">str</span>.<span class="call">isUpper</span>(letter) <span class="keyword">then</span>
      <span class="std">str</span>.<span class="call">toUpper</span>(shifted)
    <span class="keyword">else</span>
      shifted
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">-- Encode or decode a message with the ROT13 cipher</span>
<span class="comment">-- https://en.wikipedia.org/wiki/ROT13</span>

<span class="keyword">fn</span> <span class="function">cipher</span>(<span class="argument">message</span>)
  message
    <span class="operator">|</span> <span class="call">chars</span>
    <span class="operator">$</span> <span class="call">shift</span>
    <span class="operator">|</span> <span class="call">join</span>(<span class="string">&quot;&quot;</span>)
<span class="keyword">end</span>

<span class="comment">-- What does this print?</span>

<span class="string">&quot;Uryyb jbeyq!&quot;</span>
  <span class="operator">|</span> <span class="call">cipher</span>
  <span class="operator">|</span> <span class="call">print</span></code></pre>
          </div>
          <p>
            The code above implements the <em>ROT13 cipher</em>: a special case
            of the <em>Caesar cipher</em> where each letter in a message is
            replaced with the 13th letter after it in the English alphabet,
            wrapping around to the start if needed.
          </p>
          <pre><code>before encoding: a b c d e f g h i j k l m n o p q r s t u v w x y z
after encoding:  n o p q r s t u v w x y z a b c d e f g h i j k l m</code></pre>
          <p>
            For example, the ROT13 encoding of the word
            <code>&quot;cat&quot;</code> is <code>&quot;png&quot;</code>.
          </p>

          <h2>
            <a name="shifting-letters" href="#shifting-letters"
              >Shifting Letters</a
            >
          </h2>
          <p>
            To implement the cipher, we start by defining the variable
            <code>alphabet</code> as a list containing the
            <code>26</code> letters of the English alphabet. We do this using
            the <code>chars(string)</code> function to split a string of these
            letters into a list.
          </p>
          <div class="snippet">
            <pre><code class="ptls">alphabet <span class="operator">=</span> <span class="call">chars</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>)</code></pre>
            <pre
              class="result"
              style=""
            ><code><div class="var-name">alphabet</div>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</code></pre>
          </div>
          <blockquote>
            <h3>
              <a name="displaying-results" href="#displaying-results"
                >Displaying Results</a
              >
            </h3>
            <p>
              In this tutorial, the values produced by each piece of code are
              displayed automatically. In a normal Pointless program you would
              use the <code>print</code> function to display these results, for
              example <code>print(alphabet)</code>.
            </p>
          </blockquote>
          <p>
            We can use the <code>list.indexOf</code> function to get the index
            of a character within <code>alphabet</code>. For example, the letter
            <code>&quot;i&quot;</code> (the 9th letter in the alphabet) will
            have index <code>8</code> (Pointless lists are <em>0-indexed</em>).
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="std">list</span>.<span class="call">indexOf</span>(alphabet, <span class="string">&quot;i&quot;</span>)</code></pre>
            <pre class="result" style=""><code>8</code></pre>
          </div>
          <blockquote>
            <h3>
              <a
                name="standard-library-functions"
                href="#standard-library-functions"
                >Standard Library Functions</a
              >
            </h3>
            <p>
              The Pointless standard library is divided into modules like
              <code>list</code>, <code>str</code>, <code>console</code>,
              <code>math</code>, and others. These modules contain many useful
              built-in functions. For example, we can call the
              <code>toLower</code> function from the <code>str</code> module to
              convert a string to lower case.
            </p>
            <div class="snippet">
              <pre><code class="ptls"><span class="std">str</span>.<span class="call">toLower</span>(<span class="string">&quot;Pointless&quot;</span>)</code></pre>
              <pre
                class="result"
                style=""
              ><code>&quot;pointless&quot;</code></pre>
            </div>
            <p>
              Some functions like <code>str.chars</code> are available as
              globals, which means we can call them without their module prefix.
            </p>
            <div class="snippet">
              <pre><code class="ptls"><span class="call">chars</span>(<span class="string">&quot;Pointless&quot;</span>)</code></pre>
              <pre
                class="result"
                style=""
              ><code>[&quot;P&quot;, &quot;o&quot;, &quot;i&quot;, &quot;n&quot;, &quot;t&quot;, &quot;l&quot;, &quot;e&quot;, &quot;s&quot;, &quot;s&quot;]</code></pre>
            </div>
          </blockquote>
          <p>
            In addition to finding the index of a letter, we can also do the
            reverse: get a letter from the alphabet based on its index.
          </p>
          <div class="snippet">
            <pre><code class="ptls">alphabet[<span class="number">8</span>]</code></pre>
            <pre class="result" style=""><code>&quot;i&quot;</code></pre>
          </div>
          <p>At its core, our cipher will do the following for each letter:</p>
          <ul>
            <li>Convert the letter to an index.</li>
            <li>
              Shift the index value, wrapping back to the start of the alphabet
              if necessary.
            </li>
            <li>Convert the shifted index back to a letter.</li>
          </ul>
          <p>We can write a few lines of code that do just that.</p>
          <div class="snippet">
            <pre><code class="ptls">letter <span class="operator">=</span> <span class="string">&quot;i&quot;</span>
index <span class="operator">=</span> <span class="std">list</span>.<span class="call">indexOf</span>(alphabet, letter)
shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]</code></pre>
            <pre
              class="result"
              style=""
            ><code><div class="var-name">shifted</div>&quot;v&quot;</code></pre>
          </div>
          <p>
            Here, we&#39;re using <code>(index + 13) % 26</code> as our shifted
            index value. When <code>index + 13</code> is greater than or equal
            to <code>26</code>, the modulus operator will wrap the number back
            around to get a value between <code>0</code> and <code>25</code>. If
            we didn&#39;t use the modulus operator here, our code wouldn&#39;t
            work correctly for letters in the second half of the alphabet.
          </p>
          <p>
            Let&#39;s put this code into a new function called
            <code>shift</code>. The function will take a single letter and
            return the corresponding ROT13 encoded letter. We can use the
            <code>fn</code> keyword to define a new function.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">list</span>.<span class="call">indexOf</span>(alphabet, letter)
  shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]
  shifted
<span class="keyword">end</span></code></pre>
          </div>
          <blockquote>
            <h3>
              <a name="implicit-return" href="#implicit-return"
                >Implicit Return</a
              >
            </h3>
            <p>
              Pointless has a <code>return</code> keyword that can be used to
              return values from functions; however, as in other languages like
              Rust and Ruby, functions in Pointless return the value of their
              final expression by default (in this case the variable
              <code>shifted</code>), so the <code>return</code> is usually
              omitted.
            </p>
          </blockquote>
          <p>
            We can call <code>shift</code> to make sure it&#39;s working
            properly.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="call">shift</span>(<span class="string">&quot;c&quot;</span>)
<span class="call">shift</span>(<span class="string">&quot;a&quot;</span>)
<span class="call">shift</span>(<span class="string">&quot;t&quot;</span>)</code></pre>
            <pre class="result" style=""><code>&quot;p&quot;
&quot;n&quot;
&quot;g&quot;</code></pre>
          </div>
          <h2>
            <a name="shifting-whole-strings" href="#shifting-whole-strings"
              >Shifting Whole Strings</a
            >
          </h2>
          <p>
            Ultimately we want to be able to encode an entire string at once,
            instead of character-by-character. We&#39;ll define a new function
            <code>cipher</code> that takes a string <code>message</code>, calls
            the <code>shift</code> function for each letter in
            <code>message</code>, joins the shifted letters together, and
            returns the resulting encoded string.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="keyword">fn</span> <span class="function">cipher</span>(<span class="argument">message</span>)
  message
    <span class="operator">|</span> <span class="call">chars</span>
    <span class="operator">$</span> <span class="call">shift</span>
    <span class="operator">|</span> <span class="call">join</span>(<span class="string">&quot;&quot;</span>)
<span class="keyword">end</span></code></pre>
          </div>
          <p>
            Like before, we&#39;re using the <code>chars(string)</code> function
            to transform a string (<code>message</code>) into a list of
            characters; however, this time we&#39;re calling it using
            &quot;pipeline&quot; syntax. In this syntax, the pipe
            <code>|</code> operator calls the function that comes after it with
            the argument value that comes before it.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="string">&quot;cat&quot;</span> <span class="operator">|</span> <span class="call">chars</span></code></pre>
            <pre
              class="result"
              style=""
            ><code>[&quot;c&quot;, &quot;a&quot;, &quot;t&quot;]</code></pre>
          </div>
          <p>In Pointless, the following two forms are equivalent.</p>
          <div class="snippet">
            <pre><code class="ptls"><span class="call">chars</span>(message)
message <span class="operator">|</span> <span class="call">chars</span></code></pre>
          </div>
          <p>
            There&#39;s a second form of the pipeline syntax which uses the map
            <code>$</code> operator. Like the pipe <code>|</code> operator, the
            map <code>$</code> operator calls the function that comes after it
            with the argument value that comes before it, with a twist:
          </p>
          <ul>
            <li>
              It requires that its argument value is a list (or another iterable
              type).
            </li>
            <li>
              It calls the function on <strong>each</strong> element in the
              argument list.
            </li>
            <li>It returns the result of each of these calls as a new list.</li>
          </ul>
          <div class="snippet">
            <pre><code class="ptls"><span class="string">&quot;cat&quot;</span> <span class="operator">|</span> <span class="call">chars</span> <span class="operator">$</span> <span class="call">shift</span></code></pre>
            <pre
              class="result"
              style=""
            ><code>[&quot;p&quot;, &quot;n&quot;, &quot;g&quot;]</code></pre>
          </div>
          <p>
            As a final step, the <code>cipher</code> function takes the list of
            shifted letters and passes them to the
            <code>join(values, sep)</code> function, which joins them together
            into a single string with the separator <code>sep</code> in between.
            We don&#39;t want anything between the letters, so we&#39;ll use an
            empty separator <code>&quot;&quot;</code>.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="string">&quot;cat&quot;</span> <span class="operator">|</span> <span class="call">chars</span> <span class="operator">$</span> <span class="call">shift</span> <span class="operator">|</span> <span class="call">join</span>(<span class="string">&quot;&quot;</span>)</code></pre>
            <pre class="result" style=""><code>&quot;png&quot;</code></pre>
          </div>
          <p>
            Unlike <code>chars</code> and <code>shift</code>,
            <code>join</code> takes two arguments, <code>values</code> and
            <code>sep</code>. The pipe <code>|</code> operator will supply the
            first argument (<code>values</code>), but we need to specify a value
            for <code>sep</code> as well.
          </p>
          <p>In Pointless, the following two forms are equivalent.</p>
          <div class="snippet">
            <pre><code class="ptls"><span class="call">join</span>(shifted, <span class="string">&quot;&quot;</span>)
shifted <span class="operator">|</span> <span class="call">join</span>(<span class="string">&quot;&quot;</span>)</code></pre>
          </div>
          <blockquote>
            <h3>
              <a name="why-use-pipeline-syntax" href="#why-use-pipeline-syntax"
                >Why Use Pipeline Syntax?</a
              >
            </h3>
            <p>
              We didn&#39;t have to use pipeline operators to write
              <code>cipher</code>. We could have written it like this instead.
            </p>
            <div class="snippet">
              <pre><code class="ptls"><span class="keyword">fn</span> <span class="function">cipher</span>(<span class="argument">message</span>)
  <span class="call">join</span>(<span class="std">list</span>.<span class="call">map</span>(<span class="call">chars</span>(message), shift), <span class="string">&quot;&quot;</span>)
<span class="keyword">end</span></code></pre>
            </div>
            <p>
              However, I often prefer using the pipeline syntax over nested
              function calls; it lets us structure our code as a sequence of
              transformations, which can make it easier to understand and
              modify.
            </p>
            <p>
              Additionally, when writing an expression with more than one
              pipeline transformation, I like to break the code up into multiple
              lines. So, instead of writing this.
            </p>
            <div class="snippet">
              <pre><code class="ptls"><span class="string">&quot;cat&quot;</span> <span class="operator">|</span> <span class="call">chars</span> <span class="operator">$</span> <span class="call">shift</span> <span class="operator">|</span> <span class="call">join</span>(<span class="string">&quot;&quot;</span>)</code></pre>
            </div>
            <p>I write this.</p>
            <div class="snippet">
              <pre><code class="ptls"><span class="string">&quot;cat&quot;</span>
  <span class="operator">|</span> <span class="call">chars</span>
  <span class="operator">$</span> <span class="call">shift</span>
  <span class="operator">|</span> <span class="call">join</span>(<span class="string">&quot;&quot;</span>)</code></pre>
            </div>
          </blockquote>

          <h2>
            <a name="encoding-and-decoding" href="#encoding-and-decoding"
              >Encoding and Decoding</a
            >
          </h2>
          <p>
            Now let&#39;s call <code>cipher</code> to make sure it&#39;s working
            properly.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="call">cipher</span>(<span class="string">&quot;cat&quot;</span>)
<span class="call">cipher</span>(<span class="string">&quot;png&quot;</span>)</code></pre>
            <pre class="result" style=""><code>&quot;png&quot;
&quot;cat&quot;</code></pre>
          </div>
          <p>
            This example shows us something interesting: if we pass an encoded
            string (like <code>&quot;png&quot;</code>) to <code>cipher</code>,
            we get back the original unencoded string! This happens because the
            ROT13 cipher uses <code>13</code> as the shift value. When we call
            <code>cipher</code> on an encoded string, the encoded letters (which
            were already shifted <code>13</code> places from the original
            letters) are shifted <code>13</code> places again, bringing the
            total shift amount to <code>26</code>. Since our alphabet is
            <code>26</code> letters long, this process wraps each letter back to
            its original value.
            <strong
              >This means that we can use <code>cipher</code> for both encoding
              and decoding!</strong
            >
          </p>
          <p>
            We can verify this by calling <code>cipher</code> twice on the same
            message and checking that we get the original message back.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="call">cipher</span>(<span class="call">cipher</span>(<span class="string">&quot;cat&quot;</span>))</code></pre>
            <pre class="result" style=""><code>&quot;cat&quot;</code></pre>
          </div>
          <h2>
            <a name="uppercase-letters" href="#uppercase-letters"
              >Uppercase Letters</a
            >
          </h2>
          <p>Currently, our code looks like this.</p>
          <div class="snippet">
            <pre><code class="ptls">alphabet <span class="operator">=</span> <span class="call">chars</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>)

<span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">list</span>.<span class="call">indexOf</span>(alphabet, letter)
  shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]
  shifted
<span class="keyword">end</span>

<span class="keyword">fn</span> <span class="function">cipher</span>(<span class="argument">message</span>)
  message
    <span class="operator">|</span> <span class="call">chars</span>
    <span class="operator">$</span> <span class="call">shift</span>
    <span class="operator">|</span> <span class="call">join</span>(<span class="string">&quot;&quot;</span>)
<span class="keyword">end</span></code></pre>
          </div>
          <p>
            We still need to make a couple of changes. The first issue is
            uppercase letters: the <code>indexOf</code> function that we use in
            <code>shift</code> is case-sensitive, so our code won&#39;t work for
            messages containing uppercase letters. We can solve this by having
            <code>shift</code> convert <code>letter</code> to lowercase before
            finding its index.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">list</span>.<span class="call">indexOf</span>(alphabet, <span class="std">str</span>.<span class="call">toLower</span>(letter))
  shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]
  shifted
<span class="keyword">end</span></code></pre>
          </div>
          <p>
            This change allows <code>cipher</code> to handle uppercase letters,
            but we end up losing information about which letters were
            capitalized in the original message.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="call">cipher</span>(<span class="string">&quot;Cat&quot;</span>)
<span class="call">cipher</span>(<span class="call">cipher</span>(<span class="string">&quot;Cat&quot;</span>))</code></pre>
            <pre class="result" style=""><code>&quot;png&quot;
&quot;cat&quot;</code></pre>
          </div>
          <p>
            We&#39;ll update the definition for our cipher so that uppercase
            letters in <code>message</code> get translated to uppercase letters
            in the final encoded string.
          </p>
          <pre><code>before encoding: a b c d e f g h i j k l m n o p q r s t u v w x y z
after encoded:   n o p q r s t u v w x y z a b c d e f g h i j k l m

before encoding: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
after encoded:   N O P Q R S T U V W X Y Z A B C D E F G H I J K L M</code></pre>
          <p>
            We can add this behavior to <code>shift</code> using a conditional
            expression. This conditional uses the
            <code>isUpper(string)</code> function (from the
            <code>str</code> module) to check whether <code>letter</code> is
            uppercase and convert <code>shifted</code> to uppercase when
            necessary.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">list</span>.<span class="call">indexOf</span>(alphabet, <span class="std">str</span>.<span class="call">toLower</span>(letter))
  shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]

  <span class="keyword">if</span> <span class="std">str</span>.<span class="call">isUpper</span>(letter) <span class="keyword">then</span>
    <span class="std">str</span>.<span class="call">toUpper</span>(shifted)
  <span class="keyword">else</span>
    shifted
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
          </div>
          <p>Our <code>cipher</code> function now preserves letter case.</p>
          <div class="snippet">
            <pre><code class="ptls"><span class="call">cipher</span>(<span class="string">&quot;Cat&quot;</span>)
<span class="call">cipher</span>(<span class="call">cipher</span>(<span class="string">&quot;Cat&quot;</span>))</code></pre>
            <pre class="result" style=""><code>&quot;Png&quot;
&quot;Cat&quot;</code></pre>
          </div>
          <blockquote>
            <h3>
              <a
                name="conditionals-are-expressions"
                href="#conditionals-are-expressions"
                >Conditionals Are Expressions</a
              >
            </h3>
            <p>
              In Pointless, as in many other functional languages,
              <strong>conditionals are expressions</strong>, which means we can
              use them within larger pieces of code such as variable assignments
              and return expressions.
            </p>
            <div class="snippet">
              <pre><code class="ptls">a <span class="operator">=</span> <span class="number">7</span>
b <span class="operator">=</span> <span class="number">8</span>
maximum <span class="operator">=</span> <span class="keyword">if</span> a <span class="operator">&gt;</span> b <span class="keyword">then</span> a <span class="keyword">else</span> b <span class="keyword">end</span></code></pre>
              <pre
                class="result"
                style=""
              ><code><div class="var-name">maximum</div>8</code></pre>
            </div>
          </blockquote>

          <h2>
            <a name="nonalphabetic-characters" href="#nonalphabetic-characters"
              >Non-Alphabetic Characters</a
            >
          </h2>
          <p>
            The final piece to consider is non-alphabetic characters. Currently,
            if we call <code>shift</code> with a non-alphabetic character (like
            <code>&quot;!&quot;</code>), the call to
            <code>list.indexOf</code> will return <code>none</code>. This will
            cause an error later when we try to do math with the
            <code>none</code> value as though it were a number. We can fix this
            by having <code>shift</code> check whether
            <code>list.indexOf</code> returned <code>none</code> and returning
            <code>letter</code> unmodified if it did.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="keyword">fn</span> <span class="function">shift</span>(<span class="argument">letter</span>)
  index <span class="operator">=</span> <span class="std">list</span>.<span class="call">indexOf</span>(alphabet, <span class="std">str</span>.<span class="call">toLower</span>(letter))

  <span class="keyword">if</span> index <span class="operator">==</span> <span class="constant">none</span> <span class="keyword">then</span>
    letter
  <span class="keyword">else</span>
    shifted <span class="operator">=</span> alphabet[(index <span class="operator">+</span> <span class="number">13</span>) <span class="operator">%</span> <span class="number">26</span>]

    <span class="keyword">if</span> <span class="std">str</span>.<span class="call">isUpper</span>(letter) <span class="keyword">then</span>
      <span class="std">str</span>.<span class="call">toUpper</span>(shifted)
    <span class="keyword">else</span>
      shifted
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
          </div>
          <blockquote>
            <h3>
              <a
                name="conditionals-with-multiple-statements"
                href="#conditionals-with-multiple-statements"
                >Conditionals with Multiple Statements</a
              >
            </h3>
            <p>
              As this new code demonstrates, the <code>then</code> and
              <code>else</code> branches of a conditional can contain multiple
              statements. As with functions, a conditional expression takes on
              the value of the <em>final expression</em> of its matching branch.
            </p>
          </blockquote>
          <p>
            Now <code>shift</code> and <code>cipher</code> will translate
            alphabetic characters and pass non-alphabetic characters through
            unmodified.
          </p>
          <div class="snippet">
            <pre><code class="ptls"><span class="call">cipher</span>(<span class="string">&quot;Cat!&quot;</span>)
<span class="call">cipher</span>(<span class="call">cipher</span>(<span class="string">&quot;Cat!&quot;</span>))</code></pre>
            <pre class="result" style=""><code>&quot;Png!&quot;
&quot;Cat!&quot;</code></pre>
          </div>
          <p>Our code is now complete!</p>

          <h2>
            <a name="wrapping-up" href="#wrapping-up">Wrapping Up</a>
          </h2>
          <p>So, what&#39;s the secret message?</p>
          <div class="snippet">
            <pre><code class="ptls"><span class="call">cipher</span>(<span class="string">&quot;Uryyb jbeyq!&quot;</span>)</code></pre>
            <pre
              class="result"
              style=""
            ><code>&quot;Hello world!&quot;</code></pre>
          </div>
        </div>
      </div>
    </main>
  </body>
</html>
